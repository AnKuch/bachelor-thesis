\documentclass[pdftex,11pt,a4paper,twoside]{article}
\usepackage{bachelorarbeit}
\usepackage{subfigure}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage[center]{caption}
\usepackage[english]{babel}
\usepackage{tikz}
\usepackage{caption}
\usepackage{float}
\usepackage{relsize}
\usepackage{stmaryrd}
\usepackage{latexsym}
\usepackage[justification=centering]{caption}

\setlength{\parindent}{0em} %Einr√ºcken verhindern
\setcounter{tocdepth}{5}

% Zum Setzen von URLs
\usepackage{color}
\definecolor{darkred}{rgb}{.25,0,0}
\definecolor{darkgreen}{rgb}{0,.2,0}
\definecolor{darkmagenta}{rgb}{.2,0,.2}
\definecolor{darkcyan}{rgb}{0,.15,.15}
\usepackage[plainpages=false,bookmarks=true,bookmarksopen=true,colorlinks=true,
  linkcolor=darkred,citecolor=darkgreen,filecolor=darkmagenta,
  menucolor=darkred,urlcolor=darkcyan]{hyperref}

% Hier die eigenen Daten eintragen
\global\arbeit{Bachelor-Thesis}
\global\titel{Noninterference in the take-grant model for the seL4 microkernel}
\global\bearbeiter{Andrea Kuchar}
\global\betreuer{Dr Martin Hofmann, PD Dr Ulrich Sch\"opp}
\global\abgabetermin{07-27-2018}
\global\ort{Munich}
\global\fach{Computer Science}

\geometry{
  left=2.5cm,
  right=3.5cm,
  top=2cm,
  bottom=2cm,
}
\setcounter{secnumdepth}{5}

\pgfdeclareimage [ width =15 cm ]{RemoveGraphic1}{Pictures/RemoveGraphicOld/RemoveGraphic1}
\pgfdeclareimage [ width =15 cm ]{WriteGraphic1}{Pictures/WriteGraphicOld/WriteGraphic1}
\pgfdeclareimage [ width =15 cm ]{WriteGraphic2}{Pictures/WriteGraphicOld/WriteGraphic2}
\pgfdeclareimage [ width =16 cm ]{CreateUMO}{Pictures/CreateUMO/CreateUMO}
\pgfdeclareimage [ width =16 cm ]{CreateOther}{Pictures/CreateUMO/CreateOther}
\pgfdeclareimage [ width =16 cm ]{CreateOutside}{Pictures/CreateUMO/CreateOutside}
\pgfdeclareimage [ width =16 cm ]{OverviewObjects}{Pictures/OverviewObjects/OverviewObjectDomains}
\pgfdeclareimage [ width =16 cm ]{GrantTCB}{Pictures/GrantTCB/GrantTCB}
\pgfdeclareimage [ width =16 cm ]{GrantOthers}{Pictures/GrantTCB/GrantOthers}
\pgfdeclareimage [ width =16 cm ]{GrantOutside}{Pictures/GrantTCB/GrantOutside}
\pgfdeclareimage [ width =16 cm ]{WriteTCB}{Pictures/WriteTCB/WriteTCB}
\pgfdeclareimage [ width =16 cm ]{WriteOthers}{Pictures/WriteTCB/WriteOthers}
\pgfdeclareimage [ width =16 cm ]{WriteOutside}{Pictures/WriteTCB/WriteOutside}
\pgfdeclareimage [ width =16 cm ]{WriteOutside2}{Pictures/WriteTCB/WriteOutside2}
\pgfdeclareimage [ width =16 cm ]{ReadTCB}{Pictures/ReadTCB/ReadTCB}
\pgfdeclareimage [ width =16 cm ]{ReadOthers}{Pictures/ReadTCB/ReadOthers}
\pgfdeclareimage [ width =16 cm ]{ReadOutside}{Pictures/ReadTCB/ReadOutside}
\pgfdeclareimage [ width =16 cm ]{ReadOutside2}{Pictures/ReadTCB/ReadOutside2}
\pgfdeclareimage [ width =16 cm ]{RemoveCNode}{Pictures/RemoveCNode/RemoveCNode}
\pgfdeclareimage [ width =16 cm ]{RemoveOthers}{Pictures/RemoveCNode/RemoveOthers}
\pgfdeclareimage [ width =16 cm ]{RemoveOutside}{Pictures/RemoveCNode/RemoveOutside}
\pgfdeclareimage [ width =16 cm ]{RemoveOutside2}{Pictures/RemoveCNode/RemoveOutside2}

\begin{document}
	
	% Cover
	\deckblatt
	
	\pagenumbering{Roman}
	% Declaration of authorship
	\declaration
	
	% Abstract
	\clearpage
	\selectlanguage{english}
	\section*{Abstract}
	\addcontentsline{toc}{section}{Abstract}
	
	 The thesis investigates the question if the specification of the seL4 access control system is strong enough to imply the Noninterference property. 
Using the verification of the Take-Grant-Protection Model \cite{TakeG} I deduce from it the Unwinding Theorem conditions of the nondeterministic intransitive Noninterference Model \cite{NonOp}. 
As the specifications and proofs of the take-grant model is developed in the theorem proof assistant Isabelle/HOL I use the same to verify the implication. 
	

	\newpage
	%Abbildungsverzeichnis
	\listoffigures
	\newpage
	% tableofcontents
	\tableofcontents

	
	\clearpage
	% Hier beginnt der eigentliche Text
	\section{Introduction}
	\pagenumbering{arabic}
	\subsection{Motivation}
Nowadays our society becomes increasingly dependet on computer systems. In more and more areas small computers take over control. Wheter it's our SmartTV, car or the control of the lights in our home. We are forced to confront ourselves with the topic how secure and reliable these systems are. \\
Especially if we entrust our live to a computer this gets an essential meaning. From board-computers in planes or cars we want to expect that they are free from defects and unhackable. But this is not the reality. We know about cars whose board-computers can be taken over easily with a smartphone from the car next to it. \\
A key component in developing secure systems is the operating-system (OS) kernel of the system. The kernel has full access to hardware resources. One defect in the kernel can have the consequence that the security and reliability of the entire system can be lost. \\
The weakness of most previous kernels was their huge amount of code and mostly their monolithic design. This makes it impossible to review or verify the code. Monolithic designs have their weak point in the fact that not only fundamental functions as interprocesscommunication, scheduling or memory management are implemented in the kernel mode but also functions like driver for hardware or virtual filesystems are integrated in it. This makes the system more vulnerable for bugs. One crashed modul can lead to a crash of the entire system. \\
The motivation behind microkernels is to reduce the  possibility of bugs in the kernel code through reducing the code to an amount as minimal as possible and excluding functions from the kernel mode. With less code it becomes more feasible to guarantee the absence of defects within the kernel through formal verification.\\
Due to the fact that we feed our smartphones, tablets, board-computers, ... with growing amounts of sensitive informations like bank data, passwords, e-mails, chats, ... the significance of security in the area of embedded systems increases. \\
Through isolation of small subsystems, like it is done in microkernels, the security already can be raised to a higher level. With testing one can depict an huge amount of bugs. But as Dijkstra said "Testing can only show the presence, not the absence, of bugs." \cite{EngTec} \\
Like I already mentioned less lines of codes make it more feasible to verify it relating to its specification. 
The seL4 microkernel is the first microkernel whose correctness is formally verified. It's a high-assurance, high-performance microkernel, primarily developed, maintained and formally verified by NICTA (now Trustworthy Systems Group at Data61) for secure embedded systems. Its security model is based on the take-grant model, which was extended for being able to reason about kernel memory consumption of components. 
	\subsection{Aim of the thesis}
	With this thesis I want to survey if the extended take-grant model is strong enough to show the noninterference property on it. \\
	The security property of noninterference ensures that there is no unwanted information flow within a system. The take-grant model is an access control model. Therefore its duty is to "control" the access or the transfer of access on objects of a system. The noninterference property assured that there is no way information can flow to undesirable parties. \\
The thesis should investigate the different systemoperations of the model regarding the thereby occurring information flow. \\
With the collected information I want to answer two questions. First if the noninterference property can be verified with the existing model and second if the noninterference property is fulfilled. 
\subsection{Structure of the thesis}
At the beginning I want to give an survey of the seL4 kernel, its set-up, the implementation of services and the memory management. For a better comprehension I then give a brief overview of the take-grant and the noninterference model. 
Chapter 3 focuses on the formalisation of the take-grant model an chapter 4 on the formalisation of the noninterference model. \\
From chapter 5 on I turn to the validation of the noninterference property. In chapter 7 the validation is subdivided into the different systemoperations. To show the property for the model I am going to extend the model in chapter 6. \\
Finally I'll take a short resume and give a prospect on the current status of the seL4 project and the possibilities to enhance this topic. 
\newpage
	\section{Requirements}
	\subsection{The seL4 Microkernel}\label{sec:seL4}
	The seL4 \cite{Manual} ist a small operation system kernel. It's based on the in the 1990s developed L4 microkernel and provieds a minimal number of services to applications, such as abstractions for virutal address spaces, threads, inter process comunication (IPC). \\
	Each abstraction ist implemented by an kernel object with methodes dependent on the abstraction it supplies. The objects can be named and accessed by capablities which are also stored in kernel objects called \textit{CNodes}. \\
	Each capability contains an target object and potentially several access rights. The access rights can be \texttt{Read, Write, Grant} and \texttt{Create}. By invoking a capability that points to the kernel object  with an corresponding method name, applications can invoke system calls. As arguments these system calls can have data or other capabilities. 
	\subsubsection{System Calls}
	Kernel provided system calls:
	\begin{itemize}
	\item \texttt{send()}: The system call argument ist delivered to the target object and the application is allowed to continue. If the target is not able to receive and/or process the arguments immediately, the sending application will be blocked until the arguments can be delivered.
	\item \texttt{NBSend()}: Like \texttt{send()}. Exception: If the message is not deliverable it's silently droped.
	\item \texttt{Call()}: Like \texttt{send()} but the application is blocked until the object provides a response, or the receiving application replies. \\
	If the argument is delivered to an application via Endpoint the receiver needs the right to respond to the sender. So in this case an additional capability is added to the arguments. 
	\item \texttt{Wait()}: If the target object is not ready \texttt{Wait()} is used by an application to block until the object is ready. 
	\item \texttt{Reply()}: Used to respond to a \texttt{Call()}, using the capability generated by the \texttt{Call()} operation.
	\item \texttt{ReplyWait()}: As a combination of \texttt{Reply()} and \texttt{Wait()} it's efficent for the common case that replying to a request and waiting for the next can be performed in a single system call. 
	\end{itemize}
	\subsubsection{Kernel Objects}\label{sec:KernelObjects}
	The kernel implements several obejects to allocate the system operations \cite{Manual}.
	\begin{itemize}
	\item \textbf{CNodes} \\
	The capabilities to invoke system calls are stored in \textbf{\textit{CNodes}}. When created they get a fixed numer of slots that can be empty or contain a capability. 
	The kernel conducts a \textbf{Capability Derivation Tree} (CDT) to keep records about the created capabilities and their associations. This is required for the revoke operation. \\ 
	They have the following operations:
\begin{itemize}
\item \texttt{Mint()} \\
creates a copy of an existing capability. The new capability is placed in a specified CNode slot and may have less rights than the parent capability. In the CDT the capability is placed as child of the original one. 
\item \texttt{Copy()} \\
is similar to the Mint operation. But the new capability has the same rights as the original one and in the CDT it's represented as a sibling of it. 
\item \texttt{Move()} \\
can maneuver a capability between two specified slots. 
\item \texttt{Mutate()} \\
moves the capability similar to \texttt{Move()} and is able to reduce it's rights like it's done in \texttt{Mint()} without an orignal copy remaining.
\item \texttt{Rotate()} \\
moves two capabilities between three slots. Replaces two \texttt{Move()} operations. 
\item \texttt{Delete()} \\
can remove a capability from a specified slot.
\item \texttt{Revoke()} \\
is used to remove a complete part of the CDT. From a defined capability on al children from the capability in the CDT are removed with \texttt{Delete()}. 
\item \texttt{Recycle()} \\
revokes all outstanding capabilities and reconfigures the object to its initial state. So the object can be reused in for another purpose.
\end{itemize}
	\item \textbf{IPC Endpoints} \\
	Endpoints are used for the \textit{interprocess communication} between threads. They can be devided into \textbf{synchronous (EP)} and \textbf{asynchronous (AEP)} endpoints. 
	Threads in the seL4 kernel are grouped into security domains. Interprocess communication between different domains is only realised via AEPs. Generally capabilities to endpoints can be restricted to be read - or write - only. 
	\item \textbf{TCP} \\
	A thread of execution in seL4 is represented by a \textit{thread control block}. It's allways associated with a CSpace (provides the capabilities required to manipulate the kernel objects) and a VSpace (provides the virtual memory environment required to contain the code and data application). \\
	The TCB object has the following methods: \\
	\texttt{CopyRegisters(), ReadRegisters(), WriteRegisters(), SetPriority(), \\ SetIPCBuffer(), SetSpace(), Configure(), Suspend(), Resume()}
	
	\begin{figure}[ht]
	\centering
		\includegraphics[width=0.7\textwidth]{./Pictures/applicationIntern.png}
	\caption[Internal repersentation of application]{Internal representation of an application in seL4 \cite{sel4}}
	\label{fig:intapp}
	\end{figure}
	
	\item \textbf{Virtual Memory}\\
	Objects in the \textit{virtual address space} (VSpace) implement services for the management of virtual memory which largely directly correspond to those of the hardware: \\
	Page Directory, Page Table, Page, ASID Control, ASID Pool \\
	Figure \ref{fig:intapp} showes how they are connected.
	\item \textbf{Interrupt Objects} \\
	Device driver applications require \texttt{Interrupt Ojects} to be capable of receiving and acknowledging interrupts from hardware devices.
	\item \textbf{Untyped Memory} \\
	\texttt{Untyped memory objects (UMO)} seclude a fixed-sized, size-aligned, continuous region of the physical memory. Each object can be devided into a group of smaller untyped memory objects. With \texttt{Retype()} a number of new kernel objects are created. It also returns capabilities to the new objects if it succeeds. 
	\end{itemize}
	\subsubsection{Memory Allocation Model} 
	A special characteristic of the seL4 is that the memomry for kernel objects is not allocated dynamically. A goal was to isolate physical memory access between appllications and to control the amount of physical memory that applications can use. \\
	To accomplish it applications get fixed sized memory reagons they have to control by themselves. \\
	Capabilities on Untyped Memory Objects (UMO) are needed to create new objects. So applications need the capabilities on UMOs to create new objects. After creation the objects have a fix amount of memory they can use. \\
	At boot time the kernel pre-allocates all the memory required for the kernel to run. This includes the space for kernel code, data and kernel stack. The kernel then creates an \textit{Initial User Thread} with associated CSpace and VSpace and hands over the remainig memory in form of capabilities on UMOs. \\
	The Initial User Thread can create smaler sized UMOs out of an UMO or \texttt{retype} it into an other object type. The creator of new objects has full authority over the objects. This "full authority" depends on the object type. \\
	Figure \ref{fig:systarch} shows a sample system architecture in which a resource manager running at user-level  has the authority to the remaining untyped memory after boot strapping. 
	
	\begin{figure}[ht]
	\centering
		\includegraphics[width=0.6\textwidth]{./Pictures/MemoryAllocation.png}
	\caption[Sample system architecture]{Sample System Configuration \cite{TakeG}}
	\label{fig:systarch}
	\end{figure}	
	
	\newpage
	\subsection{The Take-Grant Model}	
	Protection or Acces control models specify, analyse and implemente security policies. 
	The classical Take-Grant Model was primary introduced by Lipton and Snyder, 1977 in  \href{https://www.cs.nmt.edu/~doshin/t/s06/cs589/pub/2.JLS-TG.pdf}{%
		"A Linear Time Algorithm for Deciding Subject Security"}.
	\subsubsection{The classical Model}
	In the Take-Grant Model \cite{TakeG} subjects or objects are represented as nodes and authority as arcs in a directed graph that represendts the system. \\ 
	Rules for graph mutation represent the different system operations to modify  the authority distibution. 
	The most common rules in the classical model are \textit{take, grant, create} and \textit{remove}. 
	
	\begin{itemize}
	\item \textbf{take rule}: Let S,X,Y be three distinct vertices in the protection graph with an arc, labelled with $\alpha$, from X to Y and one labelled with $\gamma$ from S to X, such that t $\in \gamma.$  
	\begin{figure}[ht]
	\centering
		\includegraphics[width=0.7\textwidth]{./Pictures/takeRule.png}
	\caption[take rule]{\textit{Take} adds an edge from S to Y with the label $\beta \subseteq \alpha$. \cite{TakeG}}
	\label{fig:cltake}
	\end{figure}		
	\item \textbf{grant rule}:	Let S,X,Y agein be three distinct vertices in the graph with an arc, labelled with  $\alpha$, from S to Y and one labelled with $\gamma$ from S to X, such that g $\in \gamma$. 
	\begin{figure}[ht]
	\centering
		\includegraphics[width=0.7\textwidth]{./Pictures/grantRule.png}
	\caption[grant rule]{\textit{Grant} adds an edge from X to Y with the label $\beta \subseteq \alpha$.  \cite{TakeG}}
	\label{fig:clgrant}
	\end{figure}		
	\item \textbf{create rule}: Let S be a vertex in the graph. 
	\begin{figure}[H]
	\centering
		\includegraphics[width=0.5\textwidth]{./Pictures/createRule.png}
	\caption[create rule]{\textit{Create} adds a new node X and an arc from S to X, labelled with $\alpha$. \cite{TakeG}}
	\label{fig:clcreate}
	\end{figure}	
	\item \textbf{remove rule}: Let S, X be vertices in the graph with an arc from S to X, labelled with $\alpha$. 
	\begin{figure}[ht]
	\centering
		\includegraphics[width=0.5\textwidth]{./Pictures/removeRule.png}
	\caption[remove rule]{\textit{Remove} deletes $\beta$ labels from $\alpha$ or the arc itself if $\alpha - \beta = \lbrace\rbrace$. \cite{TakeG}}
	\label{fig:clremove}
	\end{figure}		
	\end{itemize}	
	\subsubsection{Take-Grant specified for the seL4}
	The Take-Grant Model specified in the paper "Noninterference for Operating System Kernels" \cite{TakeG} is a variant of the classical Take-Grant model. \\
	From the modifications made the one on the \textit{create rule} is the most important one. As I explained in chapter \ref{sec:seL4} authority in the kernel is implemented with capabilities. Adding a new node to the protection graph in the model corresponds to the creation of a new object a capability pointing on in it in the kernel. So the object executing the \texttt{create operation} needs a capability with \texttt{create} authority. \\
	The \textit{remove rule} was modified as it doesn't remove parts of labels anymore but the whole capability. That means the complete arc pointing on an object is removed. \\
	To diminish authority a capability has to be removed and newly created with diminished authority. \\
	With \texttt{retype} newly created capabilities are saved in a \textit{Capability Derivation Tree} (CDT) as children of the UMO. A capability can be copied with the \texttt{mint} or \texttt{imitate operation}. \\ 
	A capability  copied with \texttt{mint} is inserted in the CDT as Child of the original one. Those that are copied with \texttt{imitate} are siblings. Figure \ref{fig:cdt} showes a CDT where C1 and C2 are created from the UMO via \texttt{retype}. C3 and C4 are copied from C1 via \texttt{mint}. So they have the same or less authority as C1. C1' is copied from C1 via \texttt{imitate}. This operation transfers the same rights to the new capability. As a consequence the capability is inserted a sibling of C1. \\
	 \begin{figure}[H]
	\centering
		\includegraphics[width=0.3\textwidth]{./Pictures/CDT.jpg}
	\caption[CDT]{Example CDT with children and siblings \cite{PhDseL4}}
	\label{fig:cdt}
	\end{figure}
	To remove a set of capabilities the operation \texttt{revoke} was implemented. \\ 
	With this operation \texttt{remove} is executed on every capability that is in the CDT below the target capability. \\
	A speciality of the extendet model is that objects and subjects are called \textit{entities}.\\
	The goal of the paper "Noninterference for Operating System Kernels" was to show that it is accomblishable to implement isolated subsystems using the mechanisms of the seL4 kernel. \cite{TakeG} \\
	Isolated subsystems are implemented as a collection of \textit{connected} entities. An entity that has \textit{grant authority} on another one is connected with this entity. Authority can neither get in nor out of these isolated subsystems.\\
	The exact specificaton of subsystems and entities follows in Chapter \ref{sec:Formalisation}.
	
	\subsection{Noninterference}
	Noninterference is an enhancement of the information flow model, first published by Goguen and Meseguer in 1982 and updated in 1984. It ensures that objects and subject from different security levels don't interfere with those at other levels. In the model variables are classified to be L (low security) or H (high security, private) variables. The goal is to prevent information from H variables from flowing to L variables. \\
	I use the noninterference formulation of Geoffrey Smith \cite{InfFlow}. It says "Program c satisfies noninterference if, for
any memories $\mu$ and $\nu$ that agree on L variables, the memories produced by
running c on $\mu$ and on $\nu$ also agree on L variables (provided that both runs
terminate successfully)." \\
This means if in a program two states ar equivalent on a low level domain they are still equivalent on this level after a program was executed.\\
Central to to noninterference is the notion of a \textit{policy} $\leadsto$. It specifies the allowed information  flows between domain. $L \leadsto H$ if information is allowed to flow from domain L to domain H. \\
The model says two memories $\mu$ and $\nu$ that agree on L variables if the fullfil an equivalence relation $\mu$ $\overset{\text{L}}{\sim}$ $\nu$. \\
	The exact formalisation of noninterferenc for the validation follows in chapter \ref{FormNon}.
	\newpage
	\section{Formalisation of the Take-Grant Model}\label{sec:Formalisation}
	\subsection{Capabilities}
	In the Take-Grant model for seL4 \cite{TakeG}, where I got the formalisation from, the authors waived the usual differentation between subjects and objects and called all kernel objects \textit{entities}. \\ \\
	The entities memory address identifies them and is modeled as a natural number. \\ \\
	{\relsize{-1}
	\textbf{type$\_$synonym} \texttt{ entity$\_$id = nat}} \\ \\
	With each capability a set of rights is associated. There are four access rights in the system model:	\\ \\
	{\relsize{-1}
	\textbf{datatype} \texttt{ rights = Read | Write | Grant | Create}} 
	\begin{itemize}	
	\item \textit{Read} authorises the reading of information from another entity. 
	\item \textit{Write} authorises the writing of information to another entity. 
	\item \textit{Grant} authorises the passing of a capability to another entity. 
	\item \textit{Create} authorises the creation of new entities, which models the behavior of untyped memory objects. 
	\end{itemize} 
	A capability has two fields:
	\begin{enumerate}
	\item An identifier which names an target-entity
	\item A set of rights which defines which system-operations the source-entity is authorisied to perform on the target-entity. 
	\end{enumerate} 
	{\relsize{-1}
	\textbf{record} 
	\texttt{	
	\begin{tabular}[t]{ll}
	cap = & entity :: entity$\_$id \\
	      & rights :: rights set
	\end{tabular}} }
	\\ \\ \\
	An entity has a set of capabilities: \\ \\
	{\relsize{-1}
	\textbf{record } \texttt{ 						
	entity = caps :: cap set}} \\ \\
	The systems state includes two flields: 
	\begin{enumerate}
	\item The \texttt{heap}, which stores the entities of the system like an arry form address \texttt{0} up to and excluding \texttt{next$\_$id}.
	\item \texttt{next$\_$id} contains slot for the next entity without overlapping with an existing one. 
	\end{enumerate} 
	{\relsize{-1}	
	\textbf{record}
	\texttt{
	\begin{tabular}[t]{ll}
	state =	& heap :: entity$\_$id $\Rightarrow$ entity \\
			& next$\_$id :: entity$\_$id
	\end{tabular}}  \\
	\subsection{System Operations}\label{sec:System Operations}
	The data type \texttt{sysOps} defines the different system operations of the seL4. \\ \\
	{\relsize{-1}	
	\textbf{datatype}
	\texttt{
	\begin{tabular}[t]{lll}
	sysOps	&	=	&	SysNoOp entity$\_$id \\
			&	|	&	SysRead	entity$\_$id cap \\
			&	|	&	SysWrite entity$\_$id cap \\
			&	|	&	SysCreate entity$\_$id cap cap \\
			&	|	&	SysGrant entity$\_$id cap cap rights set \\
			&	|	&	SysRemove	entity$\_$id cap cap \\
			&	|	&	SysRevoke entity$\_$id cap
	\end{tabular}}} \\ \\ 
	The entity$\_$id in each operation is the entity initiating the operation. The first named capability is the one that is being invoked. The second capability for \texttt{SysCreate} points to the target entity for the new capability. For \texttt{SysGrant} it's the passed capability and for \texttt{SysRemove} it's the one that has to be removed. The rights set in \texttt{SysGrant} necessary for the initiating entity to have the option only to transport a subset of the authority it offers to the receiver. 	\\
	The \texttt{diminish} function applies this mask on the given acces rights: \\ \\
	{\relsize{-1}	
	\texttt{
	diminish :: "cap $\Rightarrow$ rights set $\Rightarrow$ cap" \textbf{where} \\
	diminish c R $\equiv$ c$\llparenthesis$rights := rights c $\cap$ \textit{R}$\rrparenthesis$}} \\ \\ \\
	\texttt{legal} defines on what terms any system operation is allowed. \\ \\
	{\relsize{-1}
	\texttt{legal :: "sysOPs $\Rightarrow$ state $\Rightarrow$ bool" \texttt{where}}\\ \\
	\texttt{
	\begin{tabular}{lllll}
	  	&	"legal	&	(SysNoOp e) s	&	=	&	isEntityOf s e" \\
	|	& 	"legal	&	(SysCreate e c$_1$ c$_2$) s	&  =	& (isEntityOf s e $\wedge$ {c$_1$, c$_2$} $\subseteq$ caps$\_$of s e $\wedge$ \\ & & & & Grant $\in$ rights c$_2$ $\wedge$ Create $\in$ rights c$_2$)" \\
	| 	& "legal 	& 	(SysRead e c) s	&	=	&	(isEntityOf s e $\wedge$ c $\in$ caps$\_$of s e $\wedge$ Read \\ & & & & $\in$ rights c)" \\
	|	&	"legal 	&	(SysWrite e c) s&	= 	&	(isEntityOf s e $\wedge$ c $\in$ caps$\_$of s e $\wedge$ Write \\ & & & & $\in$ rights c)" \\
	| 	&	"legal 	&	(SysGrant e c$_1$ c$_2$ r) s & = & (isEntityOf s e $\wedge$  isEntityOf s (entity c$_1$) \\ & & & & $\wedge$ {c$_1$,c$_2$} $\subseteq$ caps$\_$of s e $\wedge$ Grant $\in$ rights c$_1$)" \\
	| 	&	"legal 	&	(SysRemove e c$_1$ c$_2$) s	&  =	& (isEntityOf s e $\wedge$ c$_1$ $\in$ caps$\_$of s e)" \\
	|	&	"legal	&	(SysRevoke e c) s	&	=	&	isEntityOf s e $\wedge$ c $\in$ caps$\_$of s e"
	\end{tabular}}} \\ \\ \\
	The function \texttt{isEntityOf} tests the existence of an \texttt{entity$\_$id}, \texttt{caps$\_$of} issues the set of all capabilities  contained in the entity with the address \texttt{r} in state \texttt{s}. \\ \\
	The original executions of \texttt{SysRead} and \texttt{SysWrite} don't have an underlying function. For implying the noninterference property I have to include what happens if an entity reads or writes a value from another entity. For this purpose I defined a \texttt{readOperation} and a \texttt{writeOperation}. \\
	The \texttt{step'} and \texttt{step} functions define the execution of a single system operation: \\ \\
	{\relsize{-1}	
	\texttt{step' :: "sysOPs $\Rightarrow$ state $\Rightarrow$ state" \textbf{where}} \\
	\texttt{
	\begin{tabular}{lllll}
		&	"step'	&	(SysNoOp e) s	&	=	&	s" \\
	|	&	"step'	&	(SysRead e c) s	&	=	&	readOperation e c s" \\
	|	&	"step'	&	(SysWrite e c) s &	=	&	writeOperation e c s" \\
	|	&	"step'	&	(SysCreat e c$_1$ c$_2$) s & = & createOperation e c$_1$ c$_2$ s" \\
	|	&	"step'	&	(SysGrant e c$_1$ c$_2$ \textit{R}) s & = & grantOperation e c$_1$ c$_2$ \textit{R} s" \\
	|	&	"step'	&	(SysRemove e c$_1$ c$_2$) s & = & removeOperation e c$_1$ c$_2$ s" \\
	|	&	"step'	&	(SysRevoke	e c) s & =	&	revokeOperation e c s" 
	\end{tabular}} \\ \\
	\texttt{step :: "sysOps $\Rightarrow$ state $\Rightarrow$ state" \textbf{where} \\
	step cmd s $\equiv$ if legal cmd s then step' cmd s else s}} \\ \\
	The new defined functions \texttt{readOperation} and \texttt{writeOperation}: \\ \\
	{\relsize{-1}	
	\texttt{readOperation :: "entity$\_$id $\Rightarrow$ cap $\Rightarrow$ modify$\_$state" \textbf{where}} \\
	\texttt{"readOperation e c s $\equiv$ s$\llparenthesis$ heap := (heap s)(e := $\llparenthesis$caps = caps$\_$of s e, eValue = value$\_$of s (entity c)$\rrparenthesis$)$\rrparenthesis$"}}\\ \\
	{\relsize{-1}	
	\texttt{writeOperation :: "entity$\_$id $\Rightarrow$ cap $\Rightarrow$ modify$\_$state" \textbf{where}} \\
	\texttt{"writeOperation e c s $\equiv$ s$\llparenthesis$ heap := (heap s)(entity c := $\llparenthesis$caps = caps$\_$of s (entity c), eValue = value$\_$of s e|))|)"}}\\ \\
	The rest of the system operations stay as they are: \\ \\
	{\relsize{-1}
	\texttt{createOperation :: "entity$\_$id $\Rightarrow$ cap $\Rightarrow$ cap $\Rightarrow$ modify$\_$state" \textbf{where}} \\
  \texttt{createOperation e c$_1$ c$_2$ s $\equiv$ \\
  \begin{tabular}{ll}
            let & nullEntity = $\llparenthesis$cap = {}, eValue = NULL$\rrparenthesis$ ; \\
                & newCap = $\llparenthesis$entity = next$\_$id s, rights = all$\_$rights$\rrparenthesis$; \\
                & newTarget = $\llparenthesis$caps = {newCap} ‚à™ caps$\_$of s (entity c$_2$), eValue = NULL$\rrparenthesis$ \\
             in & s$\llparenthesis$heap := (heap s)(entity c$_2$ := newTarget, next$\_$id s := nullEntity), next$\_$id := next$\_$id s+1$\rrparenthesis$"
   \end{tabular} \\ \\ \\
    grantOperation :: "entity$\_$id $\Rightarrow$ cap $\Rightarrow$ cap $\Rightarrow$ rights set $\Rightarrow$ modify$\_$state" \textbf{where} \\
  "grantOperation e c$_1$ c$_2$ \textit{R} s $\equiv$ \\
  s$\llparenthesis$heap := (heap s)(entity c$_1$ := $\llparenthesis$caps = {diminish c$_2$ \textit{R}} $\cup$ caps$\_$of s (entity c$_1$), eValue = value$\_$of s \\(entity c$_1$)$\rrparenthesis$)$\rrparenthesis$"\\ \\ \\
   removeOperation :: "entity$\_$id $\Rightarrow$ cap $\Rightarrow$ cap $\Rightarrow$ modify$\_$state" \textbf{where} \\
  "removeOperation c$_1$ c$_2$ s $\equiv$ s$\llparenthesis$heap := (heap s)(entity c$_1$ := $\llparenthesis$caps = caps$\_$of s (entity c$_1$) - {c$_2$}, eValue = value$\_$of s (entity c$_1$)$\rrparenthesis$)$\rrparenthesis$"}} \\ \\ \\ 
\newpage
\section{Formalisation of the Noninterference Model}\label{FormNon}
For the validation I have to formalise the noninterference property. \\ \\
{\relsize{-1}
	\texttt{
noninterference :: "bool" \textbf{where} \\
"noninterference $\equiv$ $\forall$ \textit{a l h s t s' t'.}reachable \textit{s} $\wedge$ reachable \textit{t} $\wedge$ \textit{s $\overset{\text{l}}{\sim}$ t} $\wedge$ (\textit{h $\leadsto$ l $\longrightarrow$ s $\overset{\text{h}}{\sim}$ t}) $\wedge$ \\ 
\textit{(s,s')}$\in$ Step \textit{a} $\wedge$ \textit{(t,t')}$\in$ Step \textit{a} $\longrightarrow$ \textit{s' $\overset{\text{l}}{\sim}$ t'}}"} \\ \\
"\texttt{a}" names the system operation, "\texttt{l}" a low level domain, "\texttt{h}" a high level domain, from the states "\texttt{s}" and "\texttt{t}" the system operation is executed and "\texttt{s'}" and "\texttt{t'}" are the resulting states. \\ \\
First I tried to validate confidentiality for the different system operations as they are defined in the take-grant-model. With this model it's impossible to decide whether a change of value has been recognized by another domain. \\
In the paper an entity only include a set of capabilites. For my purpose I need the option to access the content of the entities. This ist because the rules for noninterference state that no information is allowed to flow from one domain to another. This includes the information stored in the kernel objects. 
Therefore I extendet the original record \texttt{entity} by adding a \textit{value} modelled by a natural number. \\ \\
My entity type: \\ \\
	{\relsize{-1}
	\textbf{record} 
	\texttt{
	\begin{tabular}[t]{ll}
	entity = & caps :: cap set \\
			 & eValue :: nat 													
	\end{tabular}}} \\ \\ \\
	To check noninterference I had to to define a few functions. \\
	\begin{enumerate}
	\item The equivalence  relation $\sim$: \\
	\texttt{s $\overset{\text{d}}{\sim}$ t} means that for every entity \texttt{e} reachable from an etnity in \texttt{d} the status of \texttt{e} in \texttt{s} and \texttt{t} has to be the same. \\
I named the function \texttt{aquiv$\_$nonin}. It compares the value and capabilities of \texttt{e} and the entities of the subsystem \texttt{e} is located in for \texttt{s} and \texttt{t}. \\ \\
{\relsize{-1}
\texttt{
aquiv$\_$nonin :: "state $\Rightarrow$ state $\Rightarrow$ subSysT $\Rightarrow$ bool" \textbf{where} \\
"aquiv$\_$nonin s t d $\equiv$ $\{\forall$ e $\in$ d. value$\_$of s e = value$\_$of t e $\wedge$ caps$\_$of s e = caps$\_$of t e $\wedge$ subSys s e = subSys t e$\}$"}} \\
\item A function to read the value of an entity: \\ \\
{\relsize{-1}
\texttt{
value$\_$of :: "state $\Rightarrow$ entity$\_$id $\Rightarrow$ nat" where \\
"value$\_$of s sref $\equiv$ eValue(heap s sref)"}} \\
\item The isolation with subsystems: \\
Subsystems are defined by entities that are \texttt{connected} with an entity \texttt{e} in a state \texttt{s}. \\ \\
To identify subsystems I need a datatype for them: \\ \\
{\relsize{-1}\textbf{type$\_$synonym}
\texttt{
subSysT = "entity$\_$id st"}} \\ \\
Now I can define Subsystems with the function \texttt{subSys}: \\ \\
{\relsize{-1}
\texttt{
subSys :: "state $\Rightarrow$ entity$\_$id $\Rightarrow$ subSysT" where \\ 
"subSys s e $\equiv$ $\{\forall$ e$_i$.in$\_$conc$\_$connected s e e$_i\}$"}} \\ \\
\texttt{in$\_$conc$\_$connected s e e$_i$} is true for entities \texttt{e} and \textbf{e$_i$} that are connected in state s. \\
\texttt{e} and \textbf{e$_i$} are connected in state \texttt{s} if a grant capability on \texttt{e$_i$} is part of \texttt{caps$\_$of e} or if a grant capability on \texttt{e} is part of \texttt{caps$\_$of e$_i$}.
\end{enumerate} 
The function \texttt{caps$\_$of e$_i$} was defined in chapter \ref{sec:Formalisation}. 
\newpage
\section{Validation of Noninterference}\label{ValNon}
After the formalisations in chapter \ref{sec:Formalisation} and \ref{FormNon} I tryed to decide noniterference for the different system operations in the following way.\\ \\
I took one Low-level-Subsystem and one High-level-Subsystem with entities in them and tested for different right-sets and different operations if the noninterference-property holds. The following shows an example of this approach: \\ \\
\textbf{Preconditions:}
\begin{itemize}
\item H equates a High level domain that implements the subsystem 'H'
\item L equates a Low level domain that implements the subsystem 'L'
\item e$_1$ is an entity in H, \\
e$_2$ is an entity in L
\end{itemize}
\begin{figure}[H]
\pgfuseimage{WriteGraphic1}
\caption{Noninterfernce of Write 1}
\end{figure}
To show noninterference I checked if the criterias for \texttt{aquiv$\_$nonin s' t' L} are fulfilled after the execution of the \texttt{write operation} and the following prconditions. \\ \\
\textbf{Preconditions:} \\ \\
\begin{tabular}{ll}
* & s $\overset{\text{L}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t L	\\ 
** & writeOperation e$_2$ c$_2$ t changes e$\_1$ $\in$ H not e $\in$ L \\
*** & legal(SysWrite e$_2$ c$_1$) s = false $\Rightarrow$ s=s'
\end{tabular} \\ \\ \\
\textbf{Proof of the noninterference property for Write 1:} \\ \\
$\forall$ e$\in$L.$\{$ \\
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e$\}$
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' L $\Rightarrow$ s' $\overset{\text{L}}{\sim}$ t' \\ \\
\begin{figure}[H]
\pgfuseimage{WriteGraphic2}
\caption{Confidentiality of Write 2}
\end{figure}
\textbf{Preconditions:} \\ \\
\begin{tabular}{ll}
* & s $\overset{\text{L}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t L	\\ 
** & writeOperation e$_2$ c$_1$ s changes e$\_1$ $\in$ H no e $\in$ L \\ 
*** & writeOperation e$_2$ c$_2$ t changes e$\_1$ $\in$ H no e $\in$ L \\ \\ \\
\textbf{Proof of the noninterference property for Write:}
$\forall$ e$\in$L. \\
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' L $\Rightarrow$ s' $\overset{\text{L}}{\sim}$ t'
\newpage
\section{Redesign of the take-grant-model}
This procedure worked until I came to the remove-operation. There I got the problem, that an entity in the given model is allowed to delete a capability and with that also an object in another domain without any restrictions:
\begin{figure}[H]
\pgfuseimage{RemoveGraphic1}
\caption{No confidentiality for Remove}
\end{figure}
To research into this problem I decided to classify the entities by their types,corresponding to the kernel specification \cite{Manual}:
\begin{itemize}
\item Untyped 
\item TCB
\item Synchronous IPC Endpoint (SEP)
\item Asychronous IPC Endpoint (AEP)
\item CNode
\item VSpace
\item Interrupt Controller 
\item Interrupt Handler
\end{itemize}
The following table showes the different object types with the different operation executable on them and the corresponding take- grant system calls: 
\begin{table}[H]\relsize{-0.5}
\begin{tabular}{|l|c|c|}
\hline
Capability Type & Concrete Kernel & protection model \\
\hline
\hline
Untyped & Retype & sequence of \textit{SysCreate} \\
& Revoke & \textit{SysRevoke} \\
\hline
TCB & TreadControl & \textit{SysNoOP, SysGrant} \\
& Exchange Registers & \textit{SystWrite} or \textit{SysRead} \\
& Yield & \textit{SysNoOP} \\
\hline
Synchronous IPC & Send IPC & \textit{SysWrite} or \textit{SysNoOP} \\
(Endpoint) & Wait IPC & \textit{SysRead} \\
& Grant IPC & \textit{SysWrite, SysGrant} or \textit{SysNoOP} \\
\hline
Asynchronous IPC & Send Event & \textit{SysWrite} \\
(AsyncEndpoint) & Wait Event & \textit{SysRead} \\
\hline
CNode & imitate & \textit{SysGrant} \\
& mint & \textit{SysGrant} \\
& Remove & \textit{SysRemove} \\
& Revoke & \textit{SysRevoke} \\
& Move & \textit{SysGrant, SysRemove} \\
& Recycle & \textit{SysRevoke}, sequence of \textit{SysRemove} \\
\hline
VSpace & Install Mapping & \textit{SysGrant} \\
& Remove Mapping & \textit{SysRemove} \\
& Remap & \textit{SysRemove, SysGrant} \\
& initialise & \textit{SysNoOP} \\
\hline
InterruptController & Register interrupt & \textit{SysGrant} \\
& Unregister interrupt &  \textit{SysRemove}\\
\hline
Interrupt Handler & Acknowledge interrupt & \textit{SysWrite}\\
\hline
\end{tabular}
\caption{Relationship: operation of concrete kernel $\longleftrightarrow$ of protection model \cite{PhDseL4}} \end{table}
To discem the different object types I need to revise the entity record and the preconditions for the different system operations. \\ \\ 
\begin{tabular}{llr}
New dataype for the object types: & & The final version of the \texttt{entity} record:\\
{\relsize{-1}
	\textbf{datatype} 
	\texttt{
	\begin{tabular}[t]{lll}
	eType & = & Untyped \\
			 & | & TCB \\
			 & | & SEP \\
			 & | & AEP \\
			 & | & SPage \\
			 & | & CNode \\
			 & | & VSpace \\
			 & | & IContr \\
			 & | & IHandl							
	\end{tabular}}} 
	& &
	{\relsize{-1}
	\textbf{record} 
	\texttt{
	\begin{tabular}[t]{ll}
	entity = & caps :: cap set \\
			 & eValue :: nat \\
			 & eType :: eType										
	\end{tabular}}}
	\end{tabular} \\ \\ 
	The revised version of the \texttt{legal} function:\\
		{\relsize{-1}
	\texttt{legal :: "sysOPs $\Rightarrow$ state $\Rightarrow$ bool" \texttt{where}}\\ \\
	\texttt{
	\begin{tabular}{lllll}
	  	&	"legal	&	(SysNoOp e) s	&	=	&	isEntityOf s e" \\
	|	& 	"legal	&	(SysCreate e c$_1$ c$_2$) s	&  =	& (isEntityOf s e $\wedge$ {c$_1$, c$_2$} $\subseteq$ caps$\_$of s e $\wedge$ \\ & & & & Grant $\in$ rights c$_2$ $\wedge$ Create $\in$ rights c$_2$) $\wedge$ \\ & & & & eType (entity c$_1$ = Untyped" \\
	| 	& "legal 	& 	(SysRead e c) s	&	=	&	(isEntityOf s e $\wedge$ c $\in$ caps$\_$of s e $\wedge$ Read \\ & & & & $\in$ rights c) $\wedge$ eType (entity c) = TCB $\vee$ SEP $\vee$ AEP" \\
	|	&	"legal 	&	(SysWrite e c) s&	= 	&	(isEntityOf s e $\wedge$ c $\in$ caps$\_$of s e $\wedge$ Write \\ & & & & $\in$ rights c) $\wedge$ eType  (entity c) = TCB $\vee$ SEP $\vee$ AEP \\ & & & & $\vee$ IHandl" \\
	| 	&	"legal 	&	(SysGrant e c$_1$ c$_2$ r) s & = & (isEntityOf s e $\wedge$  isEntityOf s (entity c$_1$) \\ & & & & $\wedge$ {c$_1$,c$_2$} $\subseteq$ caps$\_$of s e $\wedge$ Grant $\in$ rights c$_1$) $\wedge$ \\ & & & & eType (entity c$_1$)  = TCB $\vee$ SEP $\vee$ CNode $\vee$ VSpace $\vee$ \\ & & & & IContr" \\
	| 	&	"legal 	&	(SysRemove e c$_1$ c$_2$) s	&  =	& (isEntityOf s e $\wedge$ c$_1$ $\in$ caps$\_$of s e)  $\wedge$ \\ & & & & eType (entity c$_1$) = CNode $\vee$ VSpace $\vee$ IContr" \\
	|	&	"legal	&	(SysRevoke e c) s	&	=	&	isEntityOf s e $\wedge$ c $\in$ caps$\_$of s e  $\wedge$ \\ & & & & eType (entity c) = Untyped $\vee$ CNode"
	\end{tabular}}} \\ \\ \\
	As mentioned in chapter \ref{sec:System Operations} (System Operations) the step function first proves if a system operation is "legal" in state s. If it is, the system operation is performed otherwise the new state s' is defined as s' = s. This means that if a system operation is not legal nothing happens. 
For the validation I took a subsystem (SS1) of one Domain (D1) and another subsystem (SS2) of a second Domain (D2). \\
In chapter \ref{sec:KernelObjects} (Kernel Objects) I explained that the only communication between Domains goes through \textit{Asynchronous Endpoints}. \\
The following figure shows an example of how the objects and methods can be placed in the domains and how the connection to \textit{Asynchronous Endpoints} is implemented if the information is allowed to flow from Domain 1 to Domain 2.
\begin{figure}[H]
\pgfuseimage{OverviewObjects}
\caption{Objects and Methods in the kernel}
\end{figure}
\newpage
\section{Validation with the new model}\label{sec:ValNew}
I examine each operation of the protection model and distinguish therefore between the different object types. \\
For this I assume that information is allowed to flow from Domain 1 to Domain 2 but not from Domain 2 to Domain 1. \\ \\
$\Rightarrow$ D1$\leadsto$D2 but D2$\not\leadsto$D1 \\ \\
Further I assume that state s is equivalent to state t for Domain 1. \\ \\
$\Rightarrow$ s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ \\
In this chapter I show that the criteria for the equivalence relation still holds in Domain 1, between s' and t', after every type of operation. 
\subsection{Create}\label{sec:Create}
Create corresponds to the \textit{Retype} operation on untyped memory. Each Domain has a own and fixed section of memory. So the UMO for \textit{Retype} is located in the same Domain as the implementing entity. Furthermore the created entity is placed in the same Domain as in the CDT it is a child of the UMO.  
\subsubsection{Create on UMO}
The following picture shows how a create operation in one Domain changes or not changes the equivalence criteria in the other domain that is not allowed to get infomation from the primer one.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{CreateUMO}
\caption{Noninterference for Create on Untyped Memory Objects}
\end{figure}
\end{flushleft}
I have to show that if s $\overset{\text{D1}}{\sim}$ t and (s,s') $\in$ Step a and (t,t') $\in$ Step a then s' $\overset{\text{D1}}{\sim}$ t'. 
s $\overset{\text{D1}}{\sim}$ t was defined in Chapter \ref{ValNon} as the boolean fuction aquiv$\_$nonin s t D1. The function is true if all entities e $\in$ D1 have the same value in s and t (value$\_$of s e = value$\_$of t e), if they also have the same capabilities in s and t (caps$\_$of s e = caps$\_$of t e) and if D1 has the same entities in s and t (subSys s e = subSys t e).\\
In the following section I show that value$\_$of s' e = value$\_$of t' e, caps$\_$of s' e = caps$\_$of t‚Äô e and subSys s' e = subSys t' e for all e $\in$ D1 after the execution of 
createOperation e$_2$ c$_1$ c$_2$ s respectively createOperation e$_2$ c$_1$ c$_2$ t. And with that I show that aquiv$\_$nonin s' t' D1. Then I can say from my definition that s' $\overset{\text{D1}}{\sim}$ t'. \\ \\
\textbf{Preconditions:} \\ \\
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\equiv$ \texttt{aquiv$\_$nonin s t D1}	\\ 
** & createOperation e$_2$ c$_1$ c$_2$ s creates e$_3$ $\in$ D2 and doesn't change or create any e $\in$ D1 \\
*** & legal (SysCreate e$_2$ c$_1$ c$_2$) t = false $\Rightarrow$ t' = t
\end{tabular}\\ \\ \\
\textbf{Proof of the noninterference property for create on UMO:}
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& (value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e)
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t' \\ \\
\textbf{With s' $\overset{\text{D1}}{\sim}$ t' the noninterference property for Create on an untyped memory object is fulfilled.} 
\subsubsection{Create on all other object types inside a domain}
If \texttt{create} is performed on another object type than an untyped memory object, the  function step' (SysCreate e c$_1$ c$_2$)s does nothing. \\
The following figure shows the createOperation for every other object type inside a domain.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{CreateOther}
\caption{Noninterference for Create on object types $\neq$ Untyped Memory Objects}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
\textbf{Preconditions:} \\ \\
* & s $\overset{\text{D1}}{\sim}$ t $\equiv$ \texttt{aquiv$\_$nonin s t D1}	\\ 
** & legal (SysCreate e$_2$ c$_1$ c$_2$) s = false $\Rightarrow$ s' = s \\ 
*** & legal (SysCreate e$_2$ c$_1$ c$_2$) t = false $\Rightarrow$ t' = t
\end{tabular}\\ \\ \\
\textbf{Proof of the noninterference property for create on other object types in a domain:}
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& (value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e)
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t' \\ \\
\textbf{With s' $\overset{\text{D1}}{\sim}$ t' the noninterference property for Create on other object types in a domain is fulfilled.} 
\subsubsection{Create on Asynchronous IPC Endpoint objects}
The next figure shows create on the AEP endpoints.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{CreateOutside}
\caption{Noninterference for Create on object types = AEP}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
\textbf{Preconditions:} \\ \\
* & s $\overset{\text{D1}}{\sim}$ t $\equiv$ \texttt{aquiv$\_$nonin s t D1}	\\ 
** & legal (SysCreate e$_2$ c$_1$ c$_2$) s = false $\Rightarrow$ s' = s \\ 
*** & legal (SysCreate e$_2$ c$_1$ c$_2$) t = false $\Rightarrow$ t' = t
\end{tabular}\\ \\ \\
\textbf{Proof of the noninterference property for create on Asynchronous IPC Endpoint objects}\\ 
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t' \\ \\
\textbf{With s' $\overset{\text{D1}}{\sim}$ t' the noninterference property for Create on Asynchronous IPC Endpoint objects is fulfilled.} 
\subsection{Grant}\label{sec:Grant}
Grant operation can only be done inside a domain from a TCB, Synchronous IPC, CNode, VSpace or Interrupt Controller object. The only object types that are able to have contact to different domains are Async IPC objects.
\subsubsection{Grant on TCB, SEP, CNode, VSpace or IContr objects} 
Now I show that any grant operation inside a Domain on one of the named objects does not affect the values, capabilities or entities of another domain. \\
Because every given object behaves the same way, I generalized e$_4$ = TCB $\vee$ SIPC $\vee$ CNode $\vee$ VSpace $\vee$ IContr.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{GrantTCB}
\caption{Noninterference for Grant on an TCB, Synchronous IPC Endpoint, CNode, VSpace or Interrupt Controller object}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & grantOperation e$_2$ c$_1$ c$_2$ R s creates c$_3$ $\in$ D2 and does not change or create any \\
& capability $\in$ D1 \\ 
*** & legal (SysGrant e$_2$ c$_1$ c$_2$ R) t = false $\Rightarrow$ t' = t
\end{tabular}\\ \\ \\
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t'
\subsubsection{Grant on other objects inside a domain} 
In this paragraph I show that an execution of the grant operation on another object than TCB, SEP, CNode, VSpace, Interrupt Controller or the object type that establish a communication interface between domains: AEP.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{GrantOthers}
\caption{Noninterference for Grant on an object $\neq$ TCB, Synchronous IPC Endpoint, CNode, VSpace, Interrupt Controller object or AEP}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & legal (SysGrant e$_2$ c$_1$ c$_2$) s = false $\Rightarrow$ s' = s \\ 
*** & legal (SysGrant e$_2$ c$_1$ c$_2$ R) t = false $\Rightarrow$ t' = t
\end{tabular}\\ \\ \\
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t' 
\subsubsection{Grant on Asynchronous IPC Endpoint objects}
The next figure illustrates grant on the two object types connecting different domains. In both cases the operation is not legal. 
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{GrantOutside}
\caption{Noninterference for Grant on an Asychronous IPC Endpoint object}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & legal (SysGrant e$_2$ c$_1$ c$_2$) s = false $\Rightarrow$ s' = s \\ 
*** & legal (SysGrant e$_2$ c$_1$ c$_2$) t = false $\Rightarrow$ t' = t
\end{tabular}\\ \\ \\
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t' 
\subsection{Write}\label{Write}
Write can be executed on TCB, SEP, AEP and Interrupt Handler objects.
\subsubsection{Write on TCB, SEP or Interrupt Handler object}
I start with the create operation on all executable objects inside a domain. So in the next figure e$_3$ = TCB $\vee$ SEP $\vee$ IHandl.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{WriteTCB}
\caption{Noninterference for Write on a TCB, Sychronous IPC Endpoint or Interrupt Handler object}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & writeOperation e$_2$ c$_1$ s only changes the value of an entity $\in$ D2 nothing in D1 \\ 
*** & legal (SysWrite e$_2$ c$_1$) t = false $\Rightarrow$ t' = t
\end{tabular} \\ \\ \\
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t' 
\subsubsection{Write on other objects $\neq$ TCB, SEP, IHandl and AEP}\label{WriteOthers}
Like in \ref{sec:Create} Create and \ref{sec:Grant} Grant there are other object types inside a domain, which are not executeable with the write operation. Those are CNodes, VSpaces, UMOs and Interrupt Controller. 
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{WriteOthers}
\caption{Noninterference for Write on other objects $\neq$ TCB, SEP, IHandl and AEP}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & legal (SysWrite e$_2$ c$_1$) s = false $\Rightarrow$ s' = s \\ 
*** & legal (SysWrite e$_2$ c$_1$) t = false $\Rightarrow$ t' = t
\end{tabular} \\ \\ \\
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t' 
\subsubsection{Write on an AEP object from Domain 2}\label{WriteOut}
In Chapter \ref{sec:ValNew} I defined the precondition $\Rightarrow$ D1$\leadsto$D2 but D2$\not\leadsto$D1. That means the rights from Domain 2 on Asychronous Endpoints are restricted to \texttt{read}. 
If the read operation is called from Domain 2 it looks like it is illustrated in Figure \ref{fig:WriteOut1}. The policy prescribes that information is only allowed to flow from Domain 1 to Domain 2 but not from Domain 2 to Domain 1. As a consequence \texttt{write} can not be part of c$_1$. 
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{WriteOutside}
\caption{Noninterference for Write on an object = AEP executed from an entity $\in$ Domain 2}
\label{fig:WriteOut1}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & legal (SysWrite e$_2$ c$_1$) s = false $\Rightarrow$ s' = s \\ 
*** & legal (SysWrite e$_2$ c$_1$) t = false $\Rightarrow$ t' = t
\end{tabular} \\ \\ \\
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t' \subsubsection{Write on an AEP object from Domain 1}\label{WriteOut2}
Write on AEP objects can be executed from Domain 1. Figure \ref{fig:WriteOut2} shows that this has no influence on the noninterference property.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{WriteOutside2}
\caption{Noninterference for Write on an object = AEP executed from an entity $\in$ D1}
\label{fig:WriteOut2}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & writeOperation e$_1$ c$_1$ s changes the value $\in$ e$_3$ $\notin$ D1. \\
& That means it has no impact on any entity $\in$ D1 \\ 
*** & legal (SysWrite e$_2$ c$_1$) t = false $\Rightarrow$ t' = t
\end{tabular} \\ \\ \\
$\forall$ e $\in$ D1. \\
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t'
\subsection{Read}\label{sec:Read}
Read is legal on TCB, Sychronous IPC Endpoint and Asynchronous IPC Endpoint objects. \\
Like in chapter \ref{Write} I distinguish between objects with legal execution of \texttt{read} on objects inside a domain, illegal execution of \texttt{read} on objects inside a domain and both on objects outside a domain.
\subsubsection{Read on TCB or Sychronous IPC Endpoint objects}
TCB and SEP objects are the two object types that are executable with \texttt{read} from an endpoint in the same domain. \\
Figure \ref{fig:ReadTCB} illustrates how the operation influences the other domain.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{ReadTCB}
\caption{Noninterference for Read on a TCB or Sychronous IPC Endpoint object}
\label{fig:ReadTCB}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & readOperation e$_2$ c$_1$ s only changes the value of an entity $\in$ D2 nothing in D1 \\ 
*** & legal (SysRead e$_2$ c$_1$) t = false $\Rightarrow$ t' = t
\end{tabular} \\ \\ \\
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t'
\subsubsection{Read on other object types inside a domain} 
Figure \ref{fig:ReadOthers} depicts the read operation on objects in the same domain on which \texttt{read} is not executable. It's similar to \texttt{write} in chapter \ref{WriteOthers}.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{ReadOthers}
\caption{Noninterference for Read on object types $\neq$ TCB, Asynchronous IPC Endpoint or Sychronous IPC Endpoint object}
\label{fig:ReadOthers}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & legal (SysRead e$_2$ c$_1$) s = false $\Rightarrow$ s' = s \\ 
*** & legal (SysRead e$_2$ c$_1$) t = false $\Rightarrow$ t' = t
\end{tabular} \\ \\ \\
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t'
\subsubsection{Read on an AEP object from Domain 1}
Similar to chapter \ref{WriteOut} \texttt{read} can only be executed from on type of Domain. Thats the one to which information is allowed to flow. In my case it's Domain 2. No infomation is allowed to flow to Domain 1. So \texttt{read} is not legal if it is executed from Domain 1.\\
Figure \ref{fig:ReadOut} shows that this does not affect Domain 1. 
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{ReadOutside2}
\caption{Noninterference for Read on object types = Asynchronous IPC Endpoint executed from Domain 1}
\label{fig:ReadOut}
\end{figure}
\end{flushleft} 
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & legal (SysRead e$_1$ c$_1$) s = false $\Rightarrow$ s' = s \\ 
*** & legal (SysRead e$_1$ c$_1$) t = false $\Rightarrow$ t' = t
\end{tabular} \\ \\ \\
$\forall$ e $\in$ D1. \\ 
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t'
\subsubsection{Read on an AEP object from Domain 2}
Read can be executed from Domain 2. In Figure \ref{fig:ReadOut2} I show the impact of this execution. 
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{ReadOutside}
\caption{Noninterference for Read on object types = Asynchronous IPC Endpoint executed from Domain 2}
\label{fig:ReadOut2}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & readOperation e$_2$ c$_1$ s changes the value $\in$ e$_3$ $\notin$ D1. \\
& That means it has no impact on any entity $\in$ D1 \\ 
*** & legal (SysRead e$_2$ c$_1$) t = false $\Rightarrow$ t' = t
\end{tabular} \\ \\ \\
$\forall$ e $\in$ D1. \\
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t'
\subsection{Remove}\label{sec:Remove}
\texttt{Remove} can be executed on CNode, VSpace or Interrupt Controller object types. \\
Like in the chapters before I distinguish between executing the operation inside and outside a domain. All legal object types are inside a domain. So I only have to differ between legal and not legal for the execution inside a domain. 
\subsubsection{Remove on CNode, VSpace or Interrupt Controller objects} 
Remove deletes a capability in an entity. This capability can point on an entity in the same domain or on an AEP object. 
\begin{itemize}
\item Target object is in the same domain \\
If the removed capability points to an entity in the same domain and  \texttt{remove} is legal for the executed entity, the operation is illustrated in figure \ref{fig:RemoveCNode}.
\begin{flushleft}
\begin{figure}[H]
\pgfuseimage{RemoveCNode}
\caption{Noninterference for Remove on object types = CNode, VSpace or IContr. The removed capability points to an entity in the same domain}
\label{fig:RemoveCNode}
\end{figure}
\end{flushleft}
\begin{tabular}{ll}
* & s $\overset{\text{D1}}{\sim}$ t $\Rightarrow$ aquiv$\_$nonin s t D1	\\ 
** & readOperation e$_2$ c$_1$ s changes the value $\in$ e$_3$ $\notin$ D1. \\
& That means it has no impact on any entity $\in$ D1 \\ 
*** & legal (SysRead e$_2$ c$_1$) t = false $\Rightarrow$ t' = t
\end{tabular} \\ \\ \\
$\forall$ e $\in$ D1. \\
\begin{tabular}{ll}
& value$\_$of s' e $\overset{\text{**}}{=}$ value$\_$of s e $\overset{\text{*}}{=}$ value$\_$of t e $\overset{\text{***}}{=}$ value$\_$of t' e \\
$\wedge$ & caps$\_$of s' e $\overset{\text{**}}{=}$ caps$\_$of s e $\overset{\text{*}}{=}$ caps$\_$of t e $\overset{\text{***}}{=}$ caps$\_$of t' e \\
$\wedge$ & subSys s' e $\overset{\text{**}}{=}$ subSys s e $\overset{\text{*}}{=}$ subSys t e $\overset{\text{***}}{=}$ subSys t' e
\end{tabular} \\
$\Rightarrow$ aquiv$\_$nonin s' t' D1 $\Rightarrow$ s' $\overset{\text{D1}}{\sim}$ t'
\end{itemize}
\subsection{Revoke}\label{sec:Revoke}
	\cleardoublepage
	\begin{thebibliography}{99}

	\bibitem{NonOp}
	T.\ Murray, D.\ Matichuk, M.\ Brassil, P.\ Gammie and G.\ Klein:	\\ 
	\href{http://www.ssrg.nicta.com/publications/nicta_full_text/6004.pdf}{%
		Noninterference for Operating System Kernels}. \\
    International Conference on Certified Programs and Proofs, pp. 126‚Äì142, Kyoto, Japan, December, 2012

	\bibitem{TakeG}
	D.\ Elkaduwe, G.\ Klein and K.\ Elphinstone:	\\ 
	\href{http://ts.data61.csiro.au/publications/nicta_full_text/1474.pdf}{%
		Verified Protection Model of the seL4 Microkernel}. \\
   	Technical Report NRL-1474, NICTA, October, 2007
   	
   	\bibitem{sel4}
	J.\ Andronick T.\ Bourke P.\ Derrin D.\ Greenaway D.\ Elkaduwe, G.\ Klein and K.\ Elphinstone R.\ Kolanski D.\ Matichuk T.\ Sewell S.\ Winwood:	\\ 
	\href{https://sel4.systems/Info/Docs/seL4-spec.pdf}{%
		Abstract Formal Specification of the seL4/ARMv6 API}. \\
   	Version 1.3
   	
   	\bibitem{Noninf}
	D.\ von Oheimb	\\ 
	\href{https://pdfs.semanticscholar.org/21ea/6c722535ed0a22175187796b43c114e14ee8.pdf}{%
		Information flow control revisited: Noninfluence = Noninterference + Nonleakage}. \\
   	In \textit{9th ESORICS}, volume 3193 of \textit{LNCS}, pages 225-243, 2004.
   	
   	 	\bibitem{PhDseL4}
	D.\ Elkaduwe:	\\ 
	\href{https://ts.data61.csiro.au/publications/papers/Elkaduwe:phd.pdf}{%
		A Principled Approach To Kernel Memory Management}. \\
   	PhD Thesis, UNSW CSE, Sydney, Australia, March, 2010

	\bibitem{Manual}
	M.\ Grosvenor and A.\ Walker:	\\ 
	\href{http://sel4.systems/Info/Docs/seL4-manual-latest.pdf}{%
		seL4 Reference Manual}. \\
   	Version 10.0.0
   	
   	\bibitem{InfFlow}
	G.\ Smith:\\ 
	\href{http://users.cis.fiu.edu/~smithg/papers/sif06.pdf}{%
		Principles of Secure Information Flow Analysis}. \\
   	Chapter 13 (pp. 291-307) of Malware Detection,  Springer-Verlag, 2007
   	
   	\bibitem{EngTec}
   	J.N.\ Buxton and B.\ Randell:\\
   	\href{http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1969.PDF}{%
   		Software engeneering techniques}. \\
   		Report on a conference sponsored by the NATO science committee, Rome, Italy, 27th to 31st October 1969
\end{thebibliography}
	
\end{document}